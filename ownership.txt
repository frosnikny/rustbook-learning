ВЛАДЕНИЕ — это набор правил, определяющих, как программа на Rust управляет памятью.
И стек, и куча — это части памяти, доступные вашему коду для использования во время выполнения. Однако они структурированы по-разному. Стек хранит значения в порядке их получения, а удаляет — в обратном. Это называется «последним пришёл — первым ушёл». Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер. Данные, размер которых во время компиляции неизвестен или может измениться, должны храниться в куче.
Куча менее организованна: когда вы помещаете данные в кучу, вы запрашиваете определённое место для их хранения. Распределитель памяти находит подходящее пустое место в куче, помечает его как используемое и возвращает указатель — адрес этого места. Этот процесс называется выделением в куче и иногда сокращённо просто выделением.

ПРАВИЛА ВЛАДЕНИЯ
    У каждого значения в Rust есть владелец,
    У значения может быть только один владелец в один момент времени,
    Когда владелец покидает область видимости, значение удаляется.

STRING
Создать из строкового литерала: 
    let s = String::from("hello");
Строка такого типа может быть изменяема:
    let mut s = String::from("hello");
    s.push_str(", world!"); // push_str() appends a literal to a String
    println!("{}", s); // This will print `hello, world!`

В случае строкового литерала мы знаем его содержимое во время компиляции, и оно жёстко прописано в итоговом исполняемом файле. Причина того, что строковые литералы более быстрые и эффективные, в их неизменяемости. К сожалению, нельзя поместить неопределённый кусок памяти в выполняемый файл для текста, размер которого неизвестен при компиляции и может меняться во время выполнения программы.
Тогда:
    Память должна запрашиваться у операционной системы во время выполнения программы,
    Необходим способ возврата этой памяти операционной системе, когда мы закончили в программе работу со String.
Первая часть выполняется нами: когда мы вызываем String::from, его реализация запрашивает необходимую память. 
Вторую часть делает Раст: память автоматически возвращается, как только владеющая памятью переменная выходит из области видимости.

ПЕРЕМЕЩЕНИЕ
При поверхностном копирование (=), чтобы обеспечить безопасность памяти, после строки let s2 = s1 Rust считает s1 более недействительным. Следовательно, Rust не нужно ничего освобождать, когда s1 выходит за пределы области видимости. 

КЛОНИРОВАНИЕ
Если мы хотим глубоко скопировать данные кучи String, а не только данные стека, мы можем использовать общий метод, называемый clone. 

КОПИРОВАНИЕ
Причина в том, что такие типы, как целые числа, размер которых известен во время компиляции, полностью хранятся в стеке, поэтому копии фактических значений создаются быстро. Это означает, что нет причин, по которым мы хотели бы предотвратить допустимость x после того, как создадим переменную y. Другими словами, здесь нет разницы между глубоким и поверхностным копированием, поэтому вызов clone ничем не отличается от обычного поверхностного копирования, и мы можем его опустить.


ВЛАДЕНИЕ И ФУНКЦИИ
Механика передачи значения функции аналогична тому, что происходит при присвоении значения переменной. 

Владение переменной каждый раз следует одному и тому же шаблону: присваивание значения другой переменной перемещает его. Когда переменная, содержащая данные в куче, выходит из области видимости, содержимое в куче будет очищено функцией drop, если только данные не были перемещены во владение другой переменной.
Хотя это работает, получение права владения, а затем возвращение владения каждой функцией немного утомительно. Что, если мы хотим, чтобы функция использовала значение, но не становилась владельцем? Очень раздражает, что всё, что мы передаём, также должно быть передано обратно, если мы хотим использовать это снова, в дополнение к любым данным, полученным из тела функции, которые мы также можем захотеть вернуть.
Rust позволяет нам возвращать несколько значений с помощью кортежа.
Но это слишком высокопарно и многословно для концепции, которая должна быть общей. К счастью для нас, в Rust есть возможность использовать значение без передачи права владения, называемая ссылками.

ССЫЛКИ И ЗАИМСТВОВАНИЕ
Ссылка похожа на указатель в том смысле, что это адрес, по которому мы можем проследовать, чтобы получить доступ к данным, хранящимся по этому адресу; эти данные принадлежат какой-то другой переменной. В отличие от указателя, ссылка гарантированно указывает на допустимое значение определённого типа в течение всего срока существования этой ссылки.
	fn calculate_length(s: &String) -> usize {
    	    s.len()
	}
Здесь s - ссылка, передаем так:
	let len = calculate_length(&s1);
Мы называем процесс создания ссылки заимствованием.
По умолчанию ссылка неизменяемая, чтобы это исправить необходимо добавить mut: fn change(some_string: &mut String)
Тогда передавать необходимо так: change(&mut s); (создаем изменяемую ссылку).
Изменяемые ссылки имеют одно большое ограничение: если у вас есть изменяемая ссылка на значение, у вас не может быть других ссылок на это же значение. Код, который пытается создать две изменяемые ссылки на s, завершится ошибкой.
Это позволяет предотварить "гонку данных".
Как всегда, мы можем использовать фигурные скобки для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не одновременно:
	fn main() {
	    let mut s = String::from("hello");

	    {
		let r1 = &mut s;
	    } // r1 goes out of scope here, so we can make a new reference with no problems.

	    let r2 = &mut s;
	}
	
У нас также не может быть изменяемой ссылки, пока у нас есть неизменяемая ссылка на то же значение.
Пользователи неизменяемой ссылки не ожидают, что значение внезапно изменится из-под них! Однако разрешены множественные неизменяемые ссылки, потому что никто, кто просто читает данные, не может повлиять на чтение данных кем-либо ещё.

Обратите внимание, что область действия ссылки начинается с того места, где она была введена, и продолжается до последнего использования этой ссылки. Например, этот код будет компилироваться, потому что последнее использование неизменяемых ссылок println!, происходит до того, как вводится изменяемая ссылка:
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &mut s; // no problem
    println!("{}", r3);
Области неизменяемых ссылок r1 и r2 заканчиваются после println!, где они использовались в последний раз — то есть до создания изменяемой ссылки r3. Эти области не пересекаются, поэтому этот код разрешён. Способность компилятора сообщить, что ссылка больше не используется в точке до конца области видимости, называется нелексическим временем жизни (сокращённо NLL).

ПРАВИЛА РАБОТЫ С ССЫЛКАМИ
    В один момент времени, может существовать либо одна изменяемая ссылка, либо любое количество неизменяемых ссылка,
    Все ссылки должны быть действительными.
    
Далее мы рассмотрим другой тип ссылок — срезы.

СРЕЗЫ
Срезы позволяют ссылаться на непрерывную последовательность элементов в коллекции, а не на всю коллекцию. Срез является своего рода ссылкой, поэтому он не имеет права владения.
Строковый срез - это ссылка на часть строки String и он выглядит следующим образом:
    let s = String::from("hello world");
    let hello = &s[0..5];
    let world = &s[6..11];
Внутри структура данных среза хранит начальную позицию и длину среза, что соответствует ending_index минус starting_index.

С синтаксисом Rust .., если вы хотите начать с индекса 0, вы можете отбросить значение перед двумя точками. 
Таким же образом, если ваш срез включает последний байт String, вы можете отбросить конечный номер. 
Вы также можете отбросить оба значения, чтобы получить часть всей строки.
&str - срез (строковый литерал)
Также срезы есть и для массивов
